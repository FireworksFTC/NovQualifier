#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S3,     touchSensor,    sensorTouch)
#pragma config(Sensor, S4,     compassSensor,  sensorI2CHiTechnicCompass)
#pragma config(Motor,  motorA,          ballMotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          hookMotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motor1,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motor2,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     forklift1,     tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     forklift2,     tmotorTetrix, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

//BASED IN CENTIMETERS
//TIME AND TOUCH SENSOR

//side without ball dropper thing is front

//140 is the diameter of the robot base when turning
//motor1 is on the left, motor2 on right

double timeMoved;

double currentx, currenty;

double direction;

double cmPerSecond;
double firstPowerMotor1, firstPowerMotor2;

int firstCompass;
int compassValue;

int totalEncoder;
int amountForFullHeight;
int targetEncoder;
int currentForklift;

double distanceTravelled;
double motor1Speed;
double motor2Speed;
double distanceAway;
double timeToTake;
double angleToTravel;
double hypotenuse;

int targetDegree;

bool turningRight;
bool holdingTube;
bool stationaryHook;

double timeDebug;

double sideA, sideB;

bool touched;
double addedXCoordinate;
double addedYCoordinate;
int time;

/*
what happens when the motor power doesn't change the speed? O.o
and one wheel is stationary while the other moves when turning?
*/

task keepHookMotorStill()
{
	while(true)
	{
		if (stationaryHook == true)
		{
			motor[hookMotor] = 0;
		}
		wait1Msec(100);
	}
}

void changeDirectionVariable(double angleToChange)
{
	direction = angleToChange + direction;
	if (direction >= 360)
	{
		direction = direction - 360;
	}
}

double getDistanceBasedOnTime(double time)
{
	distanceTravelled = cmPerSecond * time;

	return distanceTravelled;
}

void moveUntilTouch(double powerMotor1, double powerMotor2, bool needToSetSpeed, double timeInAddition)
{
	ClearTimer(T1);
	touched = false;
	while (SensorValue(touchSensor) == 0)
	{
		motor[motor1] = powerMotor1;
		motor[motor2] = powerMotor2;
	}
	touched = true;

	timeMoved = time1[T1] / 1000.0;
	time = time1[T1] + timeInAddition;

	if (needToSetSpeed == true)
	{
		cmPerSecond = 257 / timeMoved;
	}

	distanceTravelled = cmPerSecond * timeMoved;

	currentx = currentx + (sin(direction)*distanceTravelled);
	currenty = currenty + (cos(direction)*distanceTravelled);

	motor[motor1] = 0;
	motor[motor2] = 0;
}


void moveForTimePeriod(double powerMotor1, double powerMotor2, double time, bool moveBackwards,int xTarget,int yTarget)
{
	if (moveBackwards == true && direction > 0 && direction < 180)
	{
		time = time + (cmPerSecond)/42;  //time to move the length of the robot
	}

	if (moveBackwards == true && direction >= 180 && direction < 360)
	{
		time = time - (cmPerSecond)/42;  //time to move the length of the robot
	}

	ClearTimer(T2);

	if (holdingTube == true)
	{
		powerMotor1 = powerMotor1 * 2;
		powerMotor2 = powerMotor2 * 2;
		time = time * 9/5;
	}

	if (moveBackwards == false)
	{
		motor[motor1] = powerMotor1;
		motor[motor2] = powerMotor2;
	}

	if (moveBackwards == true)
	{
		motor[motor1] = -powerMotor1;
		motor[motor2] = -powerMotor2;
	}

	while (time1[T2] < time*1000) //time1 is in milliseconds? yes
	{
		timeDebug = time;
	}

	motor1Speed = cmPerSecond*(powerMotor1/firstPowerMotor1);
	motor2Speed = cmPerSecond*(powerMotor2/firstPowerMotor2);

	distanceTravelled = motor1Speed * time;

	addedXCoordinate = (cos(direction)*distanceTravelled);
	addedYCoordinate = (sin(direction)*distanceTravelled);

	if (xTarget != -1 && yTarget != -1)
	{
		currentx = xTarget;
		currenty = yTarget;
	}
	else
	{
		currentx = currentx + (cos(direction)*distanceTravelled);
		currenty = currenty + (sin(direction)*distanceTravelled);
	}
}

double getTimeToTake(double xTarget, double yTarget)
{
	distanceAway = sqrt(abs((currentx-xTarget)*(currentx-xTarget)
		+ (currenty-yTarget)*(currenty-yTarget))) * 1.0;

	timeToTake = distanceAway / cmPerSecond;
	return timeToTake;
}

void turnNumDegrees(int value)
{
	//add value to the current compass value (set target)
	value = value + SensorValue(compassSensor);

	//keep within 0 and 359
	if (value > 359)
	{
		value = value - 360;
	}
	if (value < 0)
	{
		value = value + 360;
	}

	//debugging
	targetDegree = value;

	//run
	while (SensorValue[compassSensor] != value)
	{
		if (SensorValue[compassSensor] > value)
		{
			motor[motor1] = -10;
			motor[motor2] = 30;
		}

		if (SensorValue[compassSensor] < value)
		{
			motor[motor1] = 30;
			motor[motor2] = -10;
		}

		compassValue = SensorValue[compassSensor];
		nxtDisplayBigStringAt(0,31,"%i",compassValue);
	}

	changeDirectionVariable(direction - value);
}

void targetAngleTurn(double xTarget, double yTarget, bool moveBackwards)
{

	sideA = abs(xTarget - currentx);
	sideB = abs(yTarget - currenty);
	hypotenuse = sqrt(sideA*sideA + sideB*sideB);

	//if robot is facing 0
	//law of cosines
	// a^2 = b^2 + c^2 - 2bc*cos(a), etc
	// cos(a) = (a^2 - b^2 - c^2)/(-2bc)

	angleToTravel = acos((sideB*sideB - sideA*sideA - hypotenuse*hypotenuse) /	(-2*sideA*hypotenuse));

	//if (currenty > yTarget)
	//{
	//	angleToTravel = acos(sideB/hypotenuse) / PI * 180;
	//}
	//else
	//{
	//	angleToTravel = acos(sideA/hypotenuse) / PI * 180;
	//}

	addedXCoordinate = (cos(direction)*distanceTravelled);
	addedYCoordinate = (sin(direction)*distanceTravelled);


	if (moveBackwards == true)
	{
		angleToTravel = angleToTravel + 180;
	}

	if (angleToTravel >= 360)
	{
		angleToTravel = angleToTravel - 360;
	}


	//if it should turn to the left instead of right so it doesn't crash into structures
	//in order: right wall, center ball container thing, ramp
	//remember the !
	if (! (currentx < 50
		|| (currentx>213 && currentx<250 && currenty<152 && currenty>243)
		|| (currentx>0 && currentx<100 && currenty<130)))
	{
		turningRight = false;
	}
	else
	{
		turningRight = true;
	}

	if (turningRight == false)
	{
		angleToTravel = 360 - angleToTravel;
	}

	turnNumDegrees(angleToTravel);

	changeDirectionVariable(angleToTravel - direction);
}

void moveToTarget(double xTarget, double yTarget, double powerMotor1, double powerMotor2, bool moveBackwards)
{
	targetAngleTurn(xTarget,yTarget, moveBackwards);

	moveForTimePeriod(powerMotor1, powerMotor2, getTimeToTake(xTarget,yTarget), moveBackwards, xTarget, yTarget);
}


void hook()
{
	stationaryHook = false;
	motor[hookMotor] = -50;
	nMotorEncoder[hookMotor] = 0;
	nMotorEncoderTarget[hookMotor] = 	-140;
	while (nMotorEncoder[hookMotor] > -140)
	{
		//Idle Loop
	}

	motor[hookMotor] = 0;
	holdingTube = true;
	stationaryHook = true;
}

void unhook()
{
	stationaryHook = false;
	motor[hookMotor] = 50;
	nMotorEncoder[hookMotor] = 0;
	nMotorEncoderTarget[hookMotor] = 	140;
	while (nMotorEncoder[hookMotor] < 140)
	{
		//Idle Loop
	}

	motor[hookMotor] = 0;
	holdingTube = false;
	stationaryHook = true;
}

void dropBalls()
{
	motor[ballMotor] = 50;
	nMotorEncoder[ballMotor] = 0;
	nMotorEncoderTarget[ballMotor] = 1080;
	while(nMotorEncoder[ballMotor] < 1080)
	{
		//idle loop
	}

	motor[ballMotor] = 0;
}

void straighten(int angleToFace)
{
	while (SensorValue[compassSensor] != angleToFace)
	{
		if (SensorValue[compassSensor] > angleToFace)
		{
			motor[motor1] = 30;
			motor[motor2] = -10;
		}

		if (SensorValue[compassSensor] < angleToFace)
		{
			motor[motor1] = -10;
			motor[motor2] = 30;
		}

		compassValue = SensorValue[compassSensor];
	}
}

void moveForklift(int height)
{

	amountForFullHeight = 2.5*PI / 16.5 * 1440;

	totalEncoder = 2.5*PI / ((height/100)*amountForFullHeight) * 1440;

	targetEncoder = amountForFullHeight - totalEncoder;

	nMotorEncoder[forklift1] = 0;
	nMotorEncoder[forklift2] = 0;

	//going down
	if (height < currentForklift)
	{
		motor[forklift1] = 5;
		motor[forklift2] = 5;
	}

	//going up
	if (height > currentForklift)
	{
		motor[forklift1] = 10;
		motor[forklift2] = 10;
	}

	nMotorEncoderTarget[forklift1] = targetEncoder;
	nMotorEncoderTarget[forklift2] = targetEncoder;

	int j = 0;
	bool firstTime = true;
	bool isStuck = false;
	ClearTimer(T1);
	while(nMotorEncoder[forklift1] < targetEncoder && isStuck == false)
	{
		if (j == nMotorEncoder[forklift1])
		{
			if (firstTime == true && time1(T1) > 1)
			{
				firstTime = false;
			}

			if (firstTime == false)
			{
				isStuck = true;
			}
		}
		else
		{
			ClearTimer(T1);
		}

		j = nMotorEncoder[forklift1];
	}
}





//FIND NEW TARGET THINGIES






task main()
{
	//waitForStart();

	wait1Msec(12);

	firstCompass = SensorValue[compassSensor];
	currentForklift = 0;

	currentx = 0;
	currenty = 0;

	firstPowerMotor1 = 10;
	firstPowerMotor2 = 10;
	cmPerSecond = 0;

	StartTask(keepHookMotorStill);

	moveForTimePeriod(10,10,4,false,-1,-1);

	straighten(firstCompass);

	moveUntilTouch(firstPowerMotor1, firstPowerMotor2,true,4); // approximately 257cm away

	hook();

	//targetx = 153;
	//targety = 5;
	moveToTarget(153,3,10,10,true);
	moveToTarget(243,3,10,10,true);

	unhook();

	//get to shortest tube
	moveToTarget(243,122,10,10,true);
	moveToTarget(91,122,10,10,false);
	moveToTarget(91,320,10,10,true);

	motor[motor1] = 0;
	motor[motor2] = 0;

	moveForklift(100);
}
