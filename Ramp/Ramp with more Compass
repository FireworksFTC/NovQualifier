#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     compassSensor,  sensorI2CHiTechnicCompass)
#pragma config(Sensor, S4,     sonarSensor,    sensorSONAR)
#pragma config(Motor,  motorA,          ballMotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          hookMotor,     tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motor1,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     motor2,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     linearSlide,   tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    ballDoor,             tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Needed for waitforstart(), but is commented to make it easier to test the program.  Placed
//in the WaitForStartRegionalRamp Program.
//#include "JoystickDriver.c"

/*
What happens when the motor power doesn't change the speed? O.o
and one wheel is stationary while the other moves when turning?
*/

//BASED IN CENTIMETERS
//TIME AND NO TOUCH SENSOR

//Side without the ball dropper thing is front
//140 is the diameter of the robot base when turning
//motor1 is on the left, motor2 on right
//365cm is the width/length of the arena

//Global variables grouped by type and relevance.
//A few are not used, since a recent verion of the
//program doesn't have a touch sensor so it doesn't
//use the variables in the touch sensor methods.
//Many of these variables are for looking at the
//numbers in the methods (for debugging).
double timeMoved;

double currentx, currenty;

double direction;

double cmPerSecond;
double firstPowerMotor1, firstPowerMotor2;

int firstCompass;
int compassValue;

int totalEncoder;
int amountForFullHeight;
int targetEncoder;
double currentLinearHeight;
double targetLinearHeight;
bool isNavigating = false;

double distanceTravelled;
double motor1Speed;
double motor2Speed;
double distanceAway;
double timeToTake;
double angleToTravel;
double hypotenuse;

int targetDegree;

bool turningRight;
bool holdingTube = false;
bool hookDown = false;

double timeDebug;

double sideA, sideB;

bool touched;
double addedXCoordinate;
double addedYCoordinate;
int time;



//A light push from the hook motor is used to keep the tube inside
//its grasp.  This is a task that goes on even when the robot
//is moving or performing other tasks.

task keepHookMotorStill()
{
	while(true)
	{
		if (holdingTube == true)
		{
			motor[hookMotor] = -100;
		}
		else
		{
			motor[hookMotor] = 20;
		}

		//This is performed every 0.1 second so it doesn't clog up
		//the CPU of the robot.
		wait1Msec(100);
	}
}

task keepCollectorRunning()
{
	ClearTimer(T3);
	while (time1(T3) < 4000)
	{
		motor[ballMotor] = -30;
	}
	motor[ballMotor] = 0;
}

//Raise the linear slide to a given height. Max height is 4 ft. Enter the height in feet (double).
task moveLinearSlide()
{
	while (true)
	{
		if (targetLinearHeight != currentLinearHeight)
		{
			isNavigating = true;

			bool goingUp;
			double timeForMaxHeight = 20;

			double ratio = targetLinearHeight/4.0;

			double time = abs(currentLinearHeight/4.0*timeForMaxHeight - timeForMaxHeight*ratio);

			//Going down.
			if (targetLinearHeight < currentLinearHeight)
			{
				motor[linearSlide] = -127;
				goingUp = false;
			}

			//Going up
			if (targetLinearHeight > currentLinearHeight)
			{
				motor[linearSlide] = 127;
				goingUp = true;
			}

			//Start moving
			ClearTimer(T1);
			while(time1(T1) < time*1000)
			{
				//It's moving! :D
			}

			motor[linearSlide] = 0;
			currentLinearHeight = targetLinearHeight;
			isNavigating = false;
		}
	}
}


//This method makes use of the compass sensor, and it is needed to straighten (as the name says)
//the robot to an angle perpendicular to the walls after it slides down the ramp. The robot's
//weight is a bit uneven, so that may be the reason why it is about 45 degrees to the left (or northwest)
//after it comes down.

//Unlike turnNumDegrees(), this is used for numbers already calibrated
//to the first number from the compass sensor. 0 is robot-decided, 1 is right, 2 is left.
void straighten(int angleToFace,int way)
{
	//Make sure the angle is within the boundaries of the values the compass sensor would normally give out.
	if (angleToFace < 0)
	{
		while (angleToFace < -360)
		{
			angleToFace += 360;
		}
	}
	if (angleToFace > 359)
	{
		while (angleToFace > 360)
		{
			angleToFace -= 360;
		}

	}

	//The acceptable range of the numbers the compass sensor will take as correct is extended to 7 numbers
	//instead of one value. This is because the robot kept on spinning forever. The wild guess of the
	//robot not finding the one specific number was made, so this was made. The change was also made for
	//the turnNumDegrees() method.

	while (!(SensorValue[compassSensor] >  angleToFace-3 && SensorValue[compassSensor] <  angleToFace+3))
	{
		//Keep on turning in the closest direction until you get the perfect number. right overrides
		//the SensorValue comparison turn.
		if (way == 1) //want to turn right
		{
			//turning right
			motor[motor1] = -20;
			motor[motor2] = 50;
		}
		else
		{
			if(way == 2)//want to turn left
			{
				motor[motor1] = 50;
				motor[motor2] = -20;
			}
			else //robot decides
			{
				if (SensorValue[compassSensor] > angleToFace)
				{
					motor[motor1] = 60;
					motor[motor2] = -90;
				}

				if (SensorValue[compassSensor] < angleToFace)
				{
					motor[motor1] = -90;
					motor[motor2] = 60;
				}
				}
		}
		compassValue = SensorValue[compassSensor];
	}
}

//Stay a certain distance from the wall.  It is to be called upon every
//time it needs an update.
void followWall(int compass)
{
	//Can make it so it doesn't have to follow a wall.
// 200 is milliseconds
// larger time makes robot go smoother because the motor power is changed less
	if (time1(T4) > 200)
	{
		if (SensorValue[compassSensor] > compass)
		{
			motor[motor1] -= 1;
			motor[motor2] += 1;
		}
		if (SensorValue[compassSensor] < compass)
		{
			motor[motor1] += 1;
			motor[motor2] -= 1;
		}
		ClearTimer(T4);
	}
}

//This method comes after moveToTarget(), or it can be called directly from the main method. You can independently enter
//motor power, how long to move, if the robot is going to move backwards (the back is the side without the hook), where
//the target will be, and if there will be drift while going down the ramp.

//The target numbers can be -1 and -1 if it the targets are unknown and the robot will caculate the position it is
//at by itself, though it might not be as accurate.

void moveForTimePeriod(double powerMotor1, double powerMotor2, double time, bool moveBackwards,
			int xTarget,int yTarget, int distance)
{
	//This is just in case the robot wants to go straight while moving, though it was pretty much scratched,
	//since the robot took too much time to check if it was still going in one direction and resulted in
	//jerky movement.
	int angle = SensorValue[compassSensor];

	//The robot's position is measured from the middle of its front, so, when it goes backwards, it needs to
	//account for its back so it doesn't crash into a wall.
	if (moveBackwards == true && direction > 0 && direction < 180)
	{
		time = time + (cmPerSecond)/42;  //time to move the length of the robot
	}

	if (moveBackwards == true && direction >= 180 && direction < 360)
	{
		time = time - (cmPerSecond)/42;  //time to move the length of the robot
	}

	//When the robot holds a tube, its weight goes up and it needs more time to make it to a
	//certain distance if it wants to use the same motor speed.
	if (holdingTube == true)
	{
		powerMotor1 = powerMotor1 * 2;
		powerMotor2 = powerMotor2 * 2;
		time = time * 9/5;
	}

	//Set the direction of the robot.
	if (moveBackwards == false)
	{
		motor[motor1] = powerMotor1;
		motor[motor2] = powerMotor2;
	}

	if (moveBackwards == true)
	{
		motor[motor1] = -powerMotor1;
		motor[motor2] = -powerMotor2;
	}

	//The robot moves according to plan. The robot may stay a certain distance from a wall.
	ClearTimer(T2);
	ClearTimer(T4);
	while (time1[T2] < time*1000) //time1 is in milliseconds? yes
	{
		timeDebug = time;
		//followWall(angle); // going to try to follow the direction according to compass
	}

	//If there is a given target value, set that as the current position, assuming the
	//robot made it. If there is no given value (-1), calculate it.
	if (xTarget != -1 && yTarget != -1)
	{
		currentx = xTarget;
		currenty = yTarget;
	}
	else
	{
		motor1Speed = cmPerSecond*(powerMotor1/firstPowerMotor1);
		motor2Speed = cmPerSecond*(powerMotor2/firstPowerMotor2);

		distanceTravelled = motor1Speed * time;

		addedXCoordinate = (cos(direction)*distanceTravelled);
		addedYCoordinate = (sin(direction)*distanceTravelled);

		currentx = currentx + addedXCoordinate;
		currenty = currenty + addedYCoordinate;
	}
}


//A variation of distance = rate * time that returns the time the robot
//should take based on the target point and speed.
double getTimeToTake(double xTarget, double yTarget)
{
	distanceAway = sqrt(abs((currentx-xTarget)*(currentx-xTarget)
		+ (currenty-yTarget)*(currenty-yTarget))) * 1.0;

	timeToTake = distanceAway / cmPerSecond;
	return timeToTake;
}

//A variation of straighten() that is based on turning a certain number of degrees, no
//mater what degree the robot is currently facing.
void turnNumDegrees(int value)
{
	//Add value to the current compass value (set target)
	value = value + SensorValue(compassSensor);

	//Keep the number within 0 and 359
	if (value > 359)
	{
		value = value - 360;
	}
	if (value < 0)
	{
		value = value + 360;
	}

	//Debugging purposes.
	targetDegree = value;

	//Identical to straighten(), except for some more debugging numbers.
	while (!(SensorValue[compassSensor] >  value-3 && SensorValue[compassSensor] <  value+3))
	{
		if (SensorValue[compassSensor] > value)
		{
			motor[motor1] = -30;
			motor[motor2] = 60;
		}

		if (SensorValue[compassSensor] < value)
		{
			motor[motor1] = 60;
			motor[motor2] = -30;
		}

		compassValue = SensorValue[compassSensor];
		nxtDisplayBigStringAt(0,31,"%i",compassValue);
	}
}


//Not needed because of compass sensor. Called by moveToTarget(), and can also be called
//from the main method. Will turn towards the target place.

void targetAngleTurn(double xTarget, double yTarget, bool moveBackwards)
{
	//Different ways to calculate how to get from one place to another.

	//Pythagorean Theorem
	sideA = abs(xTarget - currentx);
	sideB = abs(yTarget - currenty);
	hypotenuse = sqrt(sideA*sideA + sideB*sideB);

	//A failure
	//if robot is facing 0
	//law of cosines
	// a^2 = b^2 + c^2 - 2bc*cos(a), etc
	// cos(a) = (a^2 - b^2 - c^2)/(-2bc)

	//Law of Cosines
	angleToTravel = acos((sideB*sideB - sideA*sideA - hypotenuse*hypotenuse) /	(-2*sideA*hypotenuse));

	//Draw a different type of triangle (upside down or right side up).
	//if (currenty > yTarget)
	//{
	//	angleToTravel = acos(sideB/hypotenuse) / PI * 180;
	//}
	//else
	//{
	//	angleToTravel = acos(sideA/hypotenuse) / PI * 180;
	//}

	addedXCoordinate = (cos(direction)*distanceTravelled);
	addedYCoordinate = (sin(direction)*distanceTravelled);

	//Account for going backwards.
	if (moveBackwards == true)
	{
		angleToTravel = angleToTravel + 180;
	}

	if (angleToTravel >= 360)
	{
		angleToTravel = angleToTravel - 360;
	}


	//If it should turn to the left instead of right so it doesn't crash into structures
	//In order: right wall, center ball container thing, ramp
	//Remember the !
	if (! (currentx < 50
		|| (currentx>213 && currentx<250 && currenty<152 && currenty>243)
		|| (currentx>0 && currentx<100 && currenty<130)))
	{
		turningRight = false;
	}
	else
	{
		turningRight = true;
	}

	if (turningRight == false)
	{
		angleToTravel = 360 - angleToTravel;
	}

	//Turn to planned place.
	turnNumDegrees(angleToTravel);
}

//Calls a 2-step process that makes the robot turn towards the target, then go forwards to it.
void moveToTarget(double xTarget, double yTarget, double powerMotor1, double powerMotor2, bool moveBackwards, bool drift)
{
	targetAngleTurn(xTarget,yTarget, moveBackwards);

	moveForTimePeriod(powerMotor1, powerMotor2, getTimeToTake(xTarget,yTarget), moveBackwards, xTarget, yTarget, drift);
}


//Drop down the hook.

void hook()
{
	//If it has an encoder which it doesn't
	bool hasEncoder = true;

	if (hasEncoder)
	{
		motor[hookMotor] = -80;
		nMotorEncoder[hookMotor] = 0;
		ClearTimer(T1);
		//while (time1[T1] < 1500)
		while (nMotorEncoder[hookMotor] > 160 && time1[T1] < 1500)
		{
			//Idle Loop
		}

		motor[hookMotor] = 0;
		holdingTube = true;
	}
	else
	{
		//Without an encoder
		motor[hookMotor] = -30;

		wait1Msec(1500);

		motor[hookMotor] = 0;
		holdingTube = true;
	}

	wait1Msec(500);
}


//Raise the hook.

void unhook()
{
	bool hasEncoder = true;

	if (hasEncoder)
	{
		//With encoder.
		motor[hookMotor] = 100;// 100 is the speed in percentage of motor(100 is highest)
		nMotorEncoder[hookMotor] = 0; // encoder tracks how far the hook went
		ClearTimer(T1);
		while (nMotorEncoder[hookMotor] > -160 && time1[T1] < 1500)
		{
			//Idle Loop
		}

		motor[hookMotor] = 0;
		holdingTube = false;
	}
	else
	{
		//Without the encoder.
		motor[hookMotor] = 30;

		wait1Msec(500);

		motor[hookMotor] = 0;
		holdingTube = false;
	}

	wait1Msec(500);
}


//Drop balls from the container. It used to be the ziptie, but it now uses a seperate
//servo motor. It is yet to be seen how it works.

void dropBalls()
{
	bool firstRobot = false;

	if (firstRobot)
	{
		//1st robot (zipties)
		motor[ballMotor] = 50;
		nMotorEncoder[ballMotor] = 0;
		nMotorEncoderTarget[ballMotor] = 1080;
		while(nMotorEncoder[ballMotor] < 1080)
		{
			//idle loop
		}

		motor[ballMotor] = 0;
	}
	else
	{
		//2nd robot (door)

		servo[ballDoor] = 110;
		wait1Msec(2000);
		servo[ballDoor] = 256;
	}
}


void mainMethod()
{
	//Give compass sensor time to gather its BEARINGS to produce an accurate
	//firstCompass number.
	wait1Msec(50);

	//Initialization
	firstCompass = SensorValue[compassSensor];

	currentLinearHeight = 0;

	currentx = 0;
	currenty = 0;

	firstPowerMotor1 = 20;
	firstPowerMotor2 = 20;
	cmPerSecond = 50;	//Not going to calculate speed anymore because there isn't a touch sensor.

	StartTask(keepHookMotorStill);
	StartTask(keepCollectorRunning);
	StartTask(moveLinearSlide);

	//Get ready for the hooking and make sure it doesn't trip on itself
	servo[ballDoor] = 257;

	//Jumpstart time for wheels that can get stuck.
	motor[motor1] = 100;
	motor[motor2] = 100;
	wait1Msec(100);
  targetLinearHeight = 2; //DOESN'T GO UP?
	//Goes off the ramp.
	moveForTimePeriod(40,40,3,false,-1,-1,false); //motor1 power, motor2 power, time to go (seconds),
																									//true=go backwards, positionx, positiony, drift
																									//last 4 things not needed.. just copy these.
			  																					//positive forward, negative backwards.
  motor[motor1] = 0;
	motor[motor2] = 0;
	wait1Msec(1000);

	//about firstcompass+140
	straighten(firstCompass+255,1);// 2 is direction which is right; 1 is left; 0 is robot decides from which way is closer; straight uses movefortimeperiod method

	unhook();// hook goes UP, jenny

	moveForTimePeriod(-20,-20,2.5,false,-1,-1,false);

	motor[motor1] = 0;
	motor[motor2] = 0;

	while (isNavigating == true)
	{
	}
	dropBalls();
	targetLinearHeight = 0.5;

	wait1Msec(500);

	hook();

	wait1Msec(1000);
	 // hook grabs tube and goes toward parking zone

	//straighten(firstCompass+255,0);
	
	//moveForTimePeriod(50,50,1,false,-1,-1,false);// false means backwards and no compensation for drift
	
	//straighten(firstCompass+75,2);// 2 means turning right and 210 is the degrees
	
	moveForTimePeriod(50,50,2.5,false,-1,-1,false);// false means backwards and no compensation for drift
}








task main()
{
	mainMethod();
}
