
 #pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
 #pragma config(Sensor, S1,     ,               sensorI2CMuxController)
 #pragma config(Sensor, S2,     IR,             sensorHiTechnicIRSeeker1200)
 #pragma config(Sensor, S3,     TouchSensor,    sensorHiTechnicTouchMux)
 #pragma config(Motor,  motorA,          ForkLift,      tmotorNXT, PIDControl, encoder)
 #pragma config(Motor,  motorB,          Hitter,        tmotorNXT, PIDControl, encoder)
 #pragma config(Motor,  motorC,          Hook,          tmotorNXT, PIDControl, encoder)
 #pragma config(Motor,  mtr_S1_C1_1,     RightDrive,    tmotorTetrix, openLoop, reversed)
 #pragma config(Motor,  mtr_S1_C1_2,     LeftDrive,     tmotorTetrix, openLoop)
 #pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, openLoop)
 #pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
 #pragma config(Servo,  srvo_S1_C3_1,    servo1,               tServoNone)
 #pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
 #pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
 #pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
 #pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
 #pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
 //*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


 void goForward(int goPower, const int mTime){// program to make robot go backward/
 	motor[RightDrive] =  -goPower;
 	motor[LeftDrive] =  -goPower;
 	wait1Msec(mTime);
 }


 void goBack(int goPower, const int mTime) {// program to make robot go forward
 	motor[RightDrive] = goPower;
 	motor[LeftDrive] =  goPower;
 	wait1Msec(mTime);
 }


 void goLeft(int goPower, const int mTime) {// program to make robot go left
 	motor[RightDrive] = -goPower;
 	motor[LeftDrive] = goPower;
 	wait1Msec(mTime);
 }


 void goRight(int goPower, const int mTime) {// program to make robot go right
 	motor[RightDrive] = goPower;
 	motor[LeftDrive] =  -goPower;
 	wait1Msec(mTime);
 }


 void goUp (int goPower, const int mTime) {
 	motor[Hook] = -goPower;
 	wait1Msec(mTime);
 }


 void goDown (int goPower, const int mTime) {
 	motor[Hook] = goPower;
 	wait1Msec(mTime);
 }


 void goGrab (int goPower, const int mTime) {
 	motor[Hitter] = -goPower;
 	wait1Msec(mTime);
 }


 void goRelease (int goPower, const int mTime) {
 	motor[Hitter] = goPower;
 	wait1Msec(mTime);
 }




 void initializeRobot()
 {
 	return;
 }





 //task main()
 //	{
 //	goBack(10, 1000);// going forward toward IR sensor
 //	wait1Msec(2000);// waiting
 //		if(SensorValue[IR] >= 5){// condition of checking value of IR sensor; if it is greater than or equal to 5 on this check, it is in the vertical position in relation to the robot
 //			goForward(10, 750);// going away from center goal with IR sensor in order to kick kick-stand next
 //			goRight(30, 1500); // turning right to get nearer to center goal with IR sensor
 //			goBack(10, 5000); // going forward in the above direction
 //			goLeft(30, 1700);// turning toward the kick stand
 //			goBack(30, 1200);
 //			goRight(70, 1000);
 //		}
 //		else{// if the IR value wasn't greater than or equal to five during the first check, it will perform the following functions
 //			goLeft(30, 1000);// under the above else, the center goal must be in either the crooked, or horizontal positions(in relation to the robot's starting position), so the robot will turn left in order to get closer to the IR sensor
 //			goBack(20, 1500);// mover forward in the above direction
 //			if(SensorValue[IR] >= 5){// check the IR value, and if it is greater tahn or euqal to 5 at this point, it is in the crooked position(in relation to the robot's starting position)
 //				goForward(20, 1500);// Backing out in order to get in position to hit the kick stand
 //				goRight(30, 1800);// turning to be parallel to center gaol
 //				goBack(20, 1500);

 //			}
 //			else{// if the IR value wasn't greater tahn or equalt of ive during the second check, it will perform the following functions; there is only one poisiton possible left, the horizontal one(in relation to the robot's starting poisiton), so the following code is for it
 //			goRight(30, 1000);// since we originally had turned the robot left before the second IR check, we now turn right to go back to the straight forward poistion
 //			goBack(20, 280);// go forward toward the kick stand

 //			}
 //		}
 //}


 task main()
 	{
 	goBack(10, 1000);// going forward toward IR sensor
 	wait1Msec(2000);// waiting
 		if(SensorValue[IR] >= 5){// condition of checking value of IR sensor; if it is greater than or equal to 5 on this check, it is in the vertical position in relation to the robot
 	goForward(10, 750);// going away from center goal with IR sensor in order to kick kick-stand next
 			goRight(30, 1500); // turning right to get nearer to center goal with IR sensor
 			goBack(10, 5000); // going forward in the above direction
 			goLeft(30, 1700);// turning toward the kick stand
 			goBack(30, 1200);
 			goRight(70, 1000);
 			goForward(20, 3600);
 		}
 	if(SensorValue[IR] <=0){// if the IR value wasn't greater tahn or equalt of ive during the second check, it will perform the following functions; there is only one poisiton possible left, the horizontal one(in relation to the robot's starting poisiton), so the following code is for it
 				goLeft(80, 1000);// since we originally had turned the robot left before the second IR check, we now turn right to go back to the straight forward poistion
 		goBack(30, 1350);// go forward toward the kick stand
 		goLeft(50, 2000);
 		goForward(30, 1350);

 			}
 		}
