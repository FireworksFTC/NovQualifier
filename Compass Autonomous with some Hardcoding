#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     compassSensor,  sensorI2CHiTechnicCompass)
#pragma config(Motor,  motorA,          ballMotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motor1,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motor2,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     hookMotor,     tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     linearSlide,   tmotorTetrix, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

//BASED IN CENTIMETERS
//TIME AND NO TOUCH SENSOR

//Side without the ball dropper thing is front
//140 is the diameter of the robot base when turning
//motor1 is on the left, motor2 on right
//365cm is the width/length of the arena

//Global variables grouped by type and relevance. A few are not used, since a recent verion of the
//program doesn't have a touch sensor so it doesn't use the variables in the touch sensor methods.
//Many of these variables are for looking at the numbers in the methods (for debugging).

double currentx, currenty;

double direction;

double cmPerSecond;
double firstPowerMotor1, firstPowerMotor2;

int firstCompass;
int compassValue;

int currentLinearHeight;

double distanceTravelled;
double motor1Speed;
double motor2Speed;
double distanceAway;
double timeToTake;
double angleToTravel;
double hypotenuse;

int targetDegree;

bool turningRight;
bool holdingTube = false;
bool hookDown = false;

double timeDebug;

double sideA, sideB;

double addedXCoordinate;
double addedYCoordinate;

//A light push from the hook motor is used to keep the tube inside its grasp.  This is a task that goes on
//even when the robot is moving or performing other tasks.
task keepHookMotorStill()
{
	while(true)
	{
		if (holdingTube == true)
		{
			motor[hookMotor] = 1;
		}
		//This is performed every 0.1 second so it doesn't clog up
		//the CPU of the robot.
		wait1Msec(100);
	}
}

//This method is not needed since the direction variable is replaced by the compass sensor. It says here just in case
//it is needed sometime later.
void changeDirectionVariable(double angleToChange)
{
	direction = angleToChange + direction;
	if (direction >= 360)
	{
		direction = direction - 360;
	}
}

//A small method to take a bit of the length off the program.  It returns
//how far the robot went with the formula distance = rate * time.
double getDistanceBasedOnTime(double time)
{
	distanceTravelled = cmPerSecond * time;

	return distanceTravelled;
}


//This method makes use of the compas sensor, and it is needed to straighten (as the name says)
//the robot to an angle perpendicular to the walls after it slides down the ramp. The robot's
//weight is a bit uneven, so that may be the reason why it is about 45 degrees to the left (or northwest)
//after it comes down.
//Unlike turnNumDegrees(), this is used for numbers already calibrated to the first number from the compass sensor.
void straighten(int angleToFace)
{
	//Make sure the angle is within the boundaries of the values the compass sensor would normally give out.
	if (angleToFace > 359)
	{
		angleToFace = angleToFace - 360;
	}
	if (angleToFace < 0)
	{
		angleToFace = angleToFace + 360;
	}

	//The acceptable range of the numbers the compass sensor will take as correct is extened to 7 numbers
	//instead of one value. This is because the robot kept on spinning forever. The wild guess of the
	//robot not finding the one specific number was made, so this was made. The change was also made for
	//the turnNumDegrees() method.

	while (!(SensorValue[compassSensor] >  angleToFace-3 && SensorValue[compassSensor] <  angleToFace+3))
	{
		//Keep on turning in the closest direction until you get the perfect number.
		if (SensorValue[compassSensor] > angleToFace)
		{
			motor[motor1] = 60;
			motor[motor2] = -30;
		}

		if (SensorValue[compassSensor] < angleToFace)
		{
			motor[motor1] = -30;
			motor[motor2] = 60;
		}

		compassValue = SensorValue[compassSensor];
	}
}

//This method comes after moveToTarget(), or it can be called directly from the main method. You can independently enter
//motor power, how long to move, if the robot is going to move backwards (the back is the side without the hook), where
//the target will be, and if there will be drift while going down the ramp. The target numbers can be -1 and -1 if it 
//the targets are unknown and the robot will caculate the position it is at by itself, though it might not be as accurate.
void moveForTimePeriod(double powerMotor1, double powerMotor2, double time, bool moveBackwards,int xTarget,int yTarget, bool drift)
{
	//Turn a bit to the side the opposite side (the side the robot isn't leaning towards).
	if (drift)
	{
		powerMotor2 = powerMotor2*30/8;
		powerMotor1 = powerMotor1*2/12;
	}

	//This is just in case the robot wants to go straight while moving, though it was pretty much scratched,
	//since the robot took too much time to check if it was still going in one direction and resulted in
	//jerky movement.
	int angle = SensorValue[compassSensor];

	//The robot's position is measured from the middle of its front, so, when it goes backwards, it needs to
	//account for its back so it doesn't crash into a wall.
	if (moveBackwards == true && direction > 0 && direction < 180)
	{
		time = time + (cmPerSecond)/42;  //time to move the length of the robot
	}

	if (moveBackwards == true && direction >= 180 && direction < 360)
	{
		time = time - (cmPerSecond)/42;  //time to move the length of the robot
	}

	//When the robot holds a tube, its weight goes up and it needs more time to make it to a
	//certain distance if it wants to use the same motor speed.
	if (holdingTube == true)
	{
		powerMotor1 = powerMotor1 * 2;
		powerMotor2 = powerMotor2 * 2;
		time = time * 9/5;
	}

	//Set the direction of the robot.
	if (moveBackwards == false)
	{
		motor[motor1] = powerMotor1;
		motor[motor2] = powerMotor2;
	}

	if (moveBackwards == true)
	{
		motor[motor1] = -powerMotor1;
		motor[motor2] = -powerMotor2;
	}

	//The robot moves according to plan. Note the commented out method.
	ClearTimer(T2);
	while (time1[T2] < time*1000) //time1 is in milliseconds? yes
	{
		timeDebug = time;
		//straighten(angle);
	}

	//If there is a given target value, set that as the current position, assuming the
	//robot made it. If there is no given value (-1), calculate it.
	if (xTarget != -1 && yTarget != -1)
	{
		currentx = xTarget;
		currenty = yTarget;
	}
	else
	{
		motor1Speed = cmPerSecond*(powerMotor1/firstPowerMotor1);
		motor2Speed = cmPerSecond*(powerMotor2/firstPowerMotor2);

		distanceTravelled = motor1Speed * time;

		addedXCoordinate = (cos(direction)*distanceTravelled);
		addedYCoordinate = (sin(direction)*distanceTravelled);

		currentx = currentx + addedXCoordinate;
		currenty = currenty + addedYCoordinate;
	}
}

//A variation of distance = rate * time that returns the time the robot should take based on the target point and speed.
double getTimeToTake(double xTarget, double yTarget)
{
	distanceAway = sqrt(abs((currentx-xTarget)*(currentx-xTarget)
		+ (currenty-yTarget)*(currenty-yTarget))) * 1.0;

	timeToTake = distanceAway / cmPerSecond;
	return timeToTake;
}

//A variation of straighten() that is based on turning a certain number of degrees, no
//mater what degree the robot is currently facing.
void turnNumDegrees(int value)
{
	//Add value to the current compass value (set target)
	value = value + SensorValue(compassSensor);

	//Keep the number within 0 and 359
	if (value > 359)
	{
		value = value - 360;
	}
	if (value < 0)
	{
		value = value + 360;
	}

	//Debugging purposes.
	targetDegree = value;

	//Identical to straighten(), except for some more debugging numbers.
	while (!(SensorValue[compassSensor] >  value-3 && SensorValue[compassSensor] <  value+3))
	{
		if (SensorValue[compassSensor] > value)
		{
			motor[motor1] = -30;
			motor[motor2] = 60;
		}

		if (SensorValue[compassSensor] < value)
		{
			motor[motor1] = 60;
			motor[motor2] = -30;
		}

		compassValue = SensorValue[compassSensor];
		nxtDisplayBigStringAt(0,31,"%i",compassValue);
	}

	//Not needed because of compass sensor
	//changeDirectionVariable(direction - value);
}

//Not needed because of compass sensor. Called by moveToTarget(), and can also be called
//from the main method. Will turn towards the target place.
void targetAngleTurn(double xTarget, double yTarget, bool moveBackwards)
{
	//Different ways to calculate how to get from one place to another.

	//Pythagorean Theorem
	sideA = abs(xTarget - currentx);
	sideB = abs(yTarget - currenty);
	hypotenuse = sqrt(sideA*sideA + sideB*sideB);

	//A failure
	//if robot is facing 0
	//law of cosines
	// a^2 = b^2 + c^2 - 2bc*cos(a), etc
	// cos(a) = (a^2 - b^2 - c^2)/(-2bc)

	//Law of Cosines
	angleToTravel = acos((sideB*sideB - sideA*sideA - hypotenuse*hypotenuse) /	(-2*sideA*hypotenuse));

	addedXCoordinate = (cos(direction)*distanceTravelled);
	addedYCoordinate = (sin(direction)*distanceTravelled);

	//Account for going backwards.
	if (moveBackwards == true)
	{
		angleToTravel = angleToTravel + 180;
	}

	if (angleToTravel >= 360)
	{
		angleToTravel = angleToTravel - 360;
	}


	//If it should turn to the left instead of right so it doesn't crash into structures
	//In order: right wall, center ball container thing, ramp
	//Remember the !
	if (! (currentx < 50
		|| (currentx>213 && currentx<250 && currenty<152 && currenty>243)
		|| (currentx>0 && currentx<100 && currenty<130)))
	{
		turningRight = false;
	}
	else
	{
		turningRight = true;
	}

	if (turningRight == false)
	{
		angleToTravel = 360 - angleToTravel;
	}

	//Turn to planned place.
	turnNumDegrees(angleToTravel);

	//Not needed because of compass sensor.
	changeDirectionVariable(angleToTravel - direction);
}

//Calls a 2-step process that makes the robot turn towards the target, then go forwards to it.
void moveToTarget(double xTarget, double yTarget, double powerMotor1, double powerMotor2, bool moveBackwards, bool drift)
{
	targetAngleTurn(xTarget,yTarget, moveBackwards);

	moveForTimePeriod(powerMotor1, powerMotor2, getTimeToTake(xTarget,yTarget), moveBackwards, xTarget, yTarget, drift);
}

//Drop down the hook.
void hook()
{
	//Uncomment the one that isn't used (encoder or no encoder)

	//hookDown = true;
	//motor[hookMotor] = -50;
	//nMotorEncoder[hookMotor] = 0;
	//nMotorEncoderTarget[hookMotor] = 	-140;
	//while (nMotorEncoder[hookMotor] > -140)
	//{
	//	//Idle Loop
	//}

	//motor[hookMotor] = 0;
	//holdingTube = true;

	//Without an encoder
	hookDown = true;
	motor[hookMotor] = 5;

	wait1Msec(1500);

	motor[hookMotor] = 0;
	holdingTube = true;
}


//Raise the hook.
void unhook()
{
	//Uncomment the one that isn't used (encoder or no encoder)
	//With encoder.

	hookDown = false;
	motor[hookMotor] = 50;
	nMotorEncoder[hookMotor] = 0;
	nMotorEncoderTarget[hookMotor] = 	140;
	while (nMotorEncoder[hookMotor] < 140)
	{
		//Idle Loop
	}

	//Without the encoder.

	motor[hookMotor] = 0;
	holdingTube = false;

	hookDown = false;
	motor[hookMotor] = -5;

	wait1Msec(500);

	motor[hookMotor] = 0;
	holdingTube = false;
}

//Drop balls from the container. It used to be the ziptie, but it now uses a seperate
//servo motor. It is yet to be seen how it works.
void dropBalls()
{
	//not built
}

//Raise the linear slide to a given height. Max height is 4 ft. Enter the height in feet (double).
void moveLinearSlide(double height)
{
	bool goingUp;
	double timeForMaxHeight = 40; //CHANGE WHEN MEASURED (SECONDS)

	double ratio = height/4.0;

	double time = timeForMaxHeight * ratio;

	//Going down.
	if (height < currentLinearHeight)
	{
		motor[linearSlide] = -20;
		goingUp = false;
	}

	//Going up
	if (height > currentLinearHeight)
	{
		motor[linearSlide] = 20;
		goingUp = true;
	}

	//Start moving
	ClearTimer(T1);
	while(time1(T1) < time*1000)
	{
	}
}


//Main method.
task main()
{
	waitForStart();

	//Give compass sensor time to gather its BEARINGS to produce an accurate firstCompass number.
	wait1Msec(50);

	//Initialization
	firstCompass = SensorValue[compassSensor];
	currentLinearHeight = 0;

	currentx = 0;
	currenty = 0;

	firstPowerMotor1 = 20;
	firstPowerMotor2 = 20;
	cmPerSecond = 50;	//Not going to calculate speed anymore because there isn't a touch sensor.

	StartTask(keepHookMotorStill);


	//With touch sensor. Not needed now.
	//moveForTimePeriod(10,10,4,false,-1,-1);
	//straighten(firstCompass);
	//moveUntilTouch(firstPowerMotor1, firstPowerMotor2,true,4); // approximately 257cm away

	//Get ready for the hooking and make sure it doesn't trip on itself
	//moveLinearSlide(0);

	motor[linearSlide] = 20;
	wait1Msec(3000);
	motor[linearSlide] = 0;


	unhook();

	////Jumpstart time for wheels that can get stuck.
	motor[motor1] = 100;
	motor[motor2] = 100;
	wait1Msec(100);

	////Get off ramp.
	moveToTarget(0, 90, 10, 10, false,true);
	currenty = 236; //51 inches from wall
	currentx = 50; //21 inches from wall
	motor[motor1]=0;
	motor[motor2]=0;
	wait1Msec(500);
	straighten(firstCompass);

	////Wait time to know that one step is over.
	motor[motor1] = 0;
	motor[motor2] = 0;
	wait1Msec(500);

	////Position to tube.  With drift covered, the robot is straight.
	motor[motor1] = -30;
	motor[motor2] = 60;
	wait1Msec(2100);

	////Approach the tube
	//motor[motor1] = 20;
	//motor[motor2] = 20;
	//wait1Msec(100);

	////Wait time to know that one step is over.
	motor[motor1] = 0;
	motor[motor2] = 0;
	wait1Msec(500);

	hook();

	//Go to parkingzone
	motor[motor1] = 60;
	motor[motor2] = -30;
	wait1Msec(2000);

	motor[motor1] = -70;
	motor[motor2] = -70;
	wait1Msec(5000);

	//Go back to ramp
	motor[motor1] = 60;
	motor[motor2] = -30;
	wait1Msec(8000);

	motor[motor1] = 20;
	motor[motor2] = 20;
	wait1Msec(2000);
}
