#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     compassSensor,  sensorI2CHiTechnicCompass)
#pragma config(Motor,  motorA,          ballMotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motor1,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motor2,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     hookMotor,     tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     linearSlide,   tmotorTetrix, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#include "JoystickDriver.c"

//BASED IN CENTIMETERS
//TIME AND NO TOUCH SENSOR

//side without ball dropper thing is front

//140 is the diameter of the robot base when turning
//motor1 is on the left, motor2 on right
//365cm is the width/length of the arena

double timeMoved;

double currentx, currenty;

double direction;

double cmPerSecond;
double firstPowerMotor1, firstPowerMotor2;

int firstCompass;
int compassValue;

int totalEncoder;
int amountForFullHeight;
int targetEncoder;
int currentLinearHeight;

double distanceTravelled;
double motor1Speed;
double motor2Speed;
double distanceAway;
double timeToTake;
double angleToTravel;
double hypotenuse;

int targetDegree;

bool turningRight;
bool holdingTube;
bool stationaryHook;

double timeDebug;

double sideA, sideB;

bool touched;
double addedXCoordinate;
double addedYCoordinate;
int time;

/*
what happens when the motor power doesn't change the speed? O.o
and one wheel is stationary while the other moves when turning?
*/

task keepHookMotorStill()
{
	while(true)
	{
		if (stationaryHook == true)
		{
			motor[hookMotor] = 0;
		}
		wait1Msec(100);
	}
}

void changeDirectionVariable(double angleToChange)
{
	direction = angleToChange + direction;
	if (direction >= 360)
	{
		direction = direction - 360;
	}
}

double getDistanceBasedOnTime(double time)
{
	distanceTravelled = cmPerSecond * time;

	return distanceTravelled;
}

//void moveUntilTouch(double powerMotor1, double powerMotor2, bool needToSetSpeed, double timeInAddition)
//{
//	ClearTimer(T1);
//	touched = false;
//	while (SensorValue(touchSensor) == 0)
//	{
//		motor[motor1] = powerMotor1;
//		motor[motor2] = powerMotor2;
//	}
//	touched = true;

//	timeMoved = time1[T1] / 1000.0;
//	time = time1[T1] + timeInAddition;

//	if (needToSetSpeed == true)
//	{
//		cmPerSecond = 257 / timeMoved;
//	}

//	distanceTravelled = cmPerSecond * timeMoved;

//	currentx = currentx + (sin(direction)*distanceTravelled);
//	currenty = currenty + (cos(direction)*distanceTravelled);

//	motor[motor1] = 0;
//	motor[motor2] = 0;
//}

void straighten(int angleToFace)
{
	while (SensorValue[compassSensor] != angleToFace)
	{
		if (SensorValue[compassSensor] > angleToFace)
		{
			motor[motor1] = 60;
			motor[motor2] = -30;
		}

		if (SensorValue[compassSensor] < angleToFace)
		{
			motor[motor1] = -30;
			motor[motor2] = 60;
		}

		compassValue = SensorValue[compassSensor];
	}
}

void moveForTimePeriod(double powerMotor1, double powerMotor2, double time, bool moveBackwards,int xTarget,int yTarget)
{
	int angle = SensorValue(compassSensor);

	if (moveBackwards == true && direction > 0 && direction < 180)
	{
		time = time + (cmPerSecond)/42;  //time to move the length of the robot
	}

	if (moveBackwards == true && direction >= 180 && direction < 360)
	{
		time = time - (cmPerSecond)/42;  //time to move the length of the robot
	}

	ClearTimer(T2);

	if (holdingTube == true)
	{
		powerMotor1 = powerMotor1 * 2;
		powerMotor2 = powerMotor2 * 2;
		time = time * 9/5;
	}

	if (moveBackwards == false)
	{
		motor[motor1] = powerMotor1;
		motor[motor2] = powerMotor2;
	}

	if (moveBackwards == true)
	{
		motor[motor1] = -powerMotor1;
		motor[motor2] = -powerMotor2;
	}

	while (time1[T2] < time*1000) //time1 is in milliseconds? yes
	{
		timeDebug = time;
		//straighten(angle);
	}

	motor1Speed = cmPerSecond*(powerMotor1/firstPowerMotor1);
	motor2Speed = cmPerSecond*(powerMotor2/firstPowerMotor2);

	distanceTravelled = motor1Speed * time;

	addedXCoordinate = (cos(direction)*distanceTravelled);
	addedYCoordinate = (sin(direction)*distanceTravelled);

	if (xTarget != -1 && yTarget != -1)
	{
		currentx = xTarget;
		currenty = yTarget;
	}
	else
	{
		currentx = currentx + (cos(direction)*distanceTravelled);
		currenty = currenty + (sin(direction)*distanceTravelled);
	}
}

double getTimeToTake(double xTarget, double yTarget)
{
	distanceAway = sqrt(abs((currentx-xTarget)*(currentx-xTarget)
		+ (currenty-yTarget)*(currenty-yTarget))) * 1.0;

	timeToTake = distanceAway / cmPerSecond;
	return timeToTake;
}

void turnNumDegrees(int value)
{
	//add value to the current compass value (set target)
	value = value + SensorValue(compassSensor);

	//keep within 0 and 359
	if (value > 359)
	{
		value = value - 360;
	}
	if (value < 0)
	{
		value = value + 360;
	}

	//debugging
	targetDegree = value;

	//run
	while (SensorValue[compassSensor] != value)
	{
		if (SensorValue[compassSensor] > value)
		{
			motor[motor1] = -30;
			motor[motor2] = 60;
		}

		if (SensorValue[compassSensor] < value)
		{
			motor[motor1] = 60;
			motor[motor2] = -30;
		}

		compassValue = SensorValue[compassSensor];
		nxtDisplayBigStringAt(0,31,"%i",compassValue);
	}

	//not needed because of compass sensor
	changeDirectionVariable(direction - value);
}

void targetAngleTurn(double xTarget, double yTarget, bool moveBackwards)
{

	sideA = abs(xTarget - currentx);
	sideB = abs(yTarget - currenty);
	hypotenuse = sqrt(sideA*sideA + sideB*sideB);

	//if robot is facing 0
	//law of cosines
	// a^2 = b^2 + c^2 - 2bc*cos(a), etc
	// cos(a) = (a^2 - b^2 - c^2)/(-2bc)

	angleToTravel = acos((sideB*sideB - sideA*sideA - hypotenuse*hypotenuse) /	(-2*sideA*hypotenuse));

	//if (currenty > yTarget)
	//{
	//	angleToTravel = acos(sideB/hypotenuse) / PI * 180;
	//}
	//else
	//{
	//	angleToTravel = acos(sideA/hypotenuse) / PI * 180;
	//}

	addedXCoordinate = (cos(direction)*distanceTravelled);
	addedYCoordinate = (sin(direction)*distanceTravelled);


	if (moveBackwards == true)
	{
		angleToTravel = angleToTravel + 180;
	}

	if (angleToTravel >= 360)
	{
		angleToTravel = angleToTravel - 360;
	}


	//if it should turn to the left instead of right so it doesn't crash into structures
	//in order: right wall, center ball container thing, ramp
	//remember the !
	if (! (currentx < 50
		|| (currentx>213 && currentx<250 && currenty<152 && currenty>243)
		|| (currentx>0 && currentx<100 && currenty<130)))
	{
		turningRight = false;
	}
	else
	{
		turningRight = true;
	}

	if (turningRight == false)
	{
		angleToTravel = 360 - angleToTravel;
	}

	turnNumDegrees(angleToTravel);

	changeDirectionVariable(angleToTravel - direction);
}

void moveToTarget(double xTarget, double yTarget, double powerMotor1, double powerMotor2, bool moveBackwards)
{
	targetAngleTurn(xTarget,yTarget, moveBackwards);

	moveForTimePeriod(powerMotor1, powerMotor2, getTimeToTake(xTarget,yTarget), moveBackwards, xTarget, yTarget);
}


void hook()
{
	//if it has an encoder which it doesn't
	//stationaryHook = false;
	//motor[hookMotor] = -50;
	//nMotorEncoder[hookMotor] = 0;
	//nMotorEncoderTarget[hookMotor] = 	-140;
	//while (nMotorEncoder[hookMotor] > -140)
	//{
	//	//Idle Loop
	//}

	//motor[hookMotor] = 0;
	//holdingTube = true;
	//stationaryHook = true;

	//without an encoder
	stationaryHook = false;
	motor[hookMotor] = 5;

	wait1Msec(1000);

	motor[hookMotor] = 0;
	holdingTube = false;
	stationaryHook = true;
}

void unhook()
{
	bool hasEncoder = false;

	if (hasEncoder == true)
	{
		stationaryHook = false;
		motor[hookMotor] = 50;
		nMotorEncoder[hookMotor] = 0;
		nMotorEncoderTarget[hookMotor] = 	140;
		while (nMotorEncoder[hookMotor] < 140)
		{
			//Idle Loop
		}

		motor[hookMotor] = 0;
		holdingTube = false;
		stationaryHook = true;
	}
	else
	{
		stationaryHook = false;
		motor[hookMotor] = -5;

		wait1Msec(1000);

		motor[hookMotor] = 0;
		holdingTube = false;
		stationaryHook = true;
	}

}

void dropBalls()
{
	//1st robot (zipties)
	//motor[ballMotor] = 50;
	//nMotorEncoder[ballMotor] = 0;
	//nMotorEncoderTarget[ballMotor] = 1080;
	//while(nMotorEncoder[ballMotor] < 1080)
	//{
	//	//idle loop
	//}

	//motor[ballMotor] = 0;

	//2nd robot (door)



	//is it a nxt motor?

	//ADD
}

//Max height is 4 ft. Enter the height in feet (double).
void moveLinearSlide(double height)
{
	bool goingUp;
	double timeForMaxHeight = 20; //CHANGE WHEN MEASURED (SECONDS)

	double ratio = height/4.0;

	double time = timeForMaxHeight * ratio;

	//going down
	if (height < currentLinearHeight)
	{
		motor[linearSlide] = -20;
		goingUp = false;
	}

	//going up
	if (height > currentLinearHeight)
	{
		motor[linearSlide] = 20;
		goingUp = true;
	}

	ClearTimer(T1);
	//start moving
	while(time1(T1) < time)
	{
		//too close.  make sure the string doesn't break
		//but this screws with the timing part so meh ;-;

		//if (time - time1(T1)*1000 < 1 && height < 0.5)
		//{
		//	if (goingUp == false)
		//	{
		//		motor[linearSlide] = -5;
		//	}
		//}

		//if (time - time1(T1)*1000 < 1 && height < 3.5)
		//{
		//	if (goingUp == true)
		//	{
		//		motor[linearSlide] = 5;
		//	}
		//}
	}
}



task main()
{
	//waitForStart();

	wait1Msec(15);

	firstCompass = SensorValue[compassSensor];
	currentLinearHeight = 0;

	currentx = 0;
	currenty = 0;

	firstPowerMotor1 = 20;
	firstPowerMotor2 = 20;
	//not going to calculate speed anymore
	cmPerSecond = 50;

	//put in raising of linear slide

	StartTask(keepHookMotorStill);

	//moveForTimePeriod(10,10,4,false,-1,-1);
	//straighten(firstCompass);
	//moveUntilTouch(firstPowerMotor1, firstPowerMotor2,true,4); // approximately 257cm away

	//jumpstart time for wheels that can get stuck
	motor[motor1] = 100;
	motor[motor2] = 100;
	wait1Msec(100);

	//get off ramp
	moveToTarget(0, 90, 10, 10, false);
	currenty = 236; //51
	currentx = 50; //21
	motor[motor1]=0;
	motor[motor2]=0;
	wait1Msec(1000);
	straighten(firstCompass); //spins forever? O.o

	motor[motor1] = 0;
	motor[motor2] = 0;
	wait1Msec(1000);
	
	//position to tube
	motor[motor1] = -30;
	motor[motor2] = 60;
	wait1Msec(1500);
	
	hook();
	
	
	
	////position around tube
	//moveToTarget(33,260,20,20,false); //13, 42

	//to ramp
	//moveToTarget(0,0,50,50,false);

	////to parking zone
	//moveToTarget(180,10,20,20,true); //put tube there and drop it
	//unhook();
	//moveToTarget(0,260,20,20,false);
	//moveToTarget(0,0,50,50,false); //get up the ramp

	//wait on the ramp
	//while(true)
	//{
	//	motor[motor1] = 0;
	//	motor[motor2] = 0;
	//}


	//moveToTarget(15, 272, 20, 20, false);
	//moveToTarget(0, 272, 20, 20, false);

	////go to tube closest to wall
	//straighten(firstCompass);
	//moveForTimePeriod(20,20,2,false,0,345);
	//hook();

	////push other tube when hooking this one.
	//moveToTarget(0,0,70, 70, true);

	//while(true)
	//{
	//	motor[motor1] = 0;
	//	motor[motor2] = 0;
	//}
}
