#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,          Collector,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          KickstandHook, tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          Hook,          tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motor1,        tmotorTetrix, PIDControl, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     motor2,        tmotorTetrix, PIDControl)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, PIDControl)
#pragma config(Motor,  mtr_S1_C2_2,     LinearSlide,   tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    Door,                 tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Tele-Operation Mode Code Template
//
// This file contains a template for simplified creation of an tele-op program for an FTC
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of tele-op mode, you may want to perform some initialization on your robot
// and the variables within your program.
//
// In most cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
  //servo[Door] = 256;
  //nMotorEncoder[LinearSlide] = 0;

  return;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the tele-op robot operation. Customize as appropriate for
// your specific robot.
//
// Game controller / joystick information is sent periodically (about every 50 milliseconds) from
// the FMS (Field Management System) to the robot. Most tele-op programs will follow the following
// logic:
//   1. Loop forever repeating the following actions:
//   2. Get the latest game controller / joystick settings that have been received from the PC.
//   3. Perform appropriate actions based on the joystick + buttons settings. This is usually a
//      simple action:
//      *  Joystick values are usually directly translated into power levels for a motor or
//         position of a servo.
//      *  Buttons are usually used to start/stop a motor or cause a servo to move to a specific
//         position.
//   4. Repeat the loop.
//
// Your program needs to continuously loop because you need to continuously respond to changes in
// the game controller settings.
//
// At the end of the tele-op period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#define DEAD_ZONE_POS 10 // The postive position to make sure the robot doesn't drift
#define DEAD_ZONE_NEG -10 // The negative position to make sure the robot doesn't drift
#define ZONE_TEN_POS 60 // The positive poisition 60; from 10< x < 60
#define ZONE_TEN_NEG -60 // The negative position -60; from -10 < x < -60
#define ZONE_SIXTY_POS 100 // The positive position 110; from 60 < x < 110 and x > 110
#define ZONE_SIXTY_NEG -100 // The negative position -110; from -60 < x < -110 and x < -110
#define MAXIMUM_POWER_POS 127 // The maximum power of the robot; 127
#define MAXIMUM_POWER_NEG -127 // The maximum power for neg of the robot; -127
#define MEDIUM_POWER_POS 60 // the medium power of the robot; 30
#define MEDIUM_POWER_NEG -60 // The medium power neg of the robot; -30
#define SMALL_POWER_POS 10 // The smallest power of the robot; 10
#define SMALL_POWER_NEG -10 // The smallest power neg of the robot; -10


//indicates encoder value for each tube and the integer encoder value

long smallHeight = 31150;
long mediumHeight = 54043;
long highestHeight = 73929;
long centerHeight = 80502;
long encoderValue = 0;
int powermotor1;
int powermotor2;


// The controling of speed with the joystick position to motor speed ratio so robot will move forward more smoothly
void ForwardSpeedController1()
{
	if(joystick.joy1_y1 <= DEAD_ZONE_POS  && joystick.joy1_y1 >= DEAD_ZONE_NEG)
	{
		motor[motor1] = 0;
	}
	else if(joystick.joy1_y1 > DEAD_ZONE_POS && joystick.joy1_y1 <= ZONE_TEN_POS)
	{
	motor[motor1] = SMALL_POWER_POS;
	}
	else if(joystick.joy1_y1 > ZONE_TEN_POS && joystick.joy1_y1 <= ZONE_SIXTY_POS)
	{
	motor[motor1] = MEDIUM_POWER_POS;
}
	else if(joystick.joy1_y1 > ZONE_SIXTY_POS)
	{
		motor[motor1] = MAXIMUM_POWER_POS;
	}
}

void ForwardSpeedController2()
{
	if(joystick.joy1_y2 <= DEAD_ZONE_POS && joystick.joy1_y2 >= DEAD_ZONE_NEG)
	{
		motor[motor2] = 0;
	}
	else if(joystick.joy1_y2 > DEAD_ZONE_POS && joystick.joy1_y2 <= ZONE_TEN_POS)
	{
		motor[motor2] = SMALL_POWER_POS;
	}
		else if(joystick.joy1_y2 > ZONE_TEN_POS && joystick.joy1_y2 <= ZONE_SIXTY_POS)
	{
		motor[motor2] = MEDIUM_POWER_POS;
}
	else if(joystick.joy1_y2 > ZONE_SIXTY_POS)
	{
		motor[motor2] = MAXIMUM_POWER_POS;
	}
}

void BackwardSpeedController1()
{
	if(joystick.joy1_y1 <= DEAD_ZONE_POS && joystick.joy1_y1 >= DEAD_ZONE_NEG)
	{
		motor[motor1] = 0;
	}
	else if(joystick.joy1_y1 < DEAD_ZONE_NEG && joystick.joy1_y1 >= ZONE_TEN_NEG)
	{
		motor[motor1] = SMALL_POWER_NEG;
	}
	else if(joystick.joy1_y1 < ZONE_TEN_NEG && joystick.joy1_y1 >= ZONE_SIXTY_NEG)
	{
		motor[motor1] = MEDIUM_POWER_NEG ;
}
	else if(joystick.joy1_y1 < ZONE_SIXTY_NEG)
	{
		motor[motor1] = MAXIMUM_POWER_NEG;
	}
}

void BackwardSpeedController2()
{
	if(joystick.joy1_y2 <= DEAD_ZONE_POS && joystick.joy1_y2 >= DEAD_ZONE_NEG)
	{
		motor[motor2] = 0;
	}
	else if(joystick.joy1_y2 < DEAD_ZONE_NEG && joystick.joy1_y2 >= ZONE_TEN_NEG)
	{
		motor[motor2] = SMALL_POWER_NEG;
	}
		else if(joystick.joy1_y2 < ZONE_TEN_NEG && joystick.joy1_y2 >= ZONE_SIXTY_NEG )
	{
		motor[motor2] = MEDIUM_POWER_NEG ;
}
	else if(joystick.joy1_y2 < ZONE_SIXTY_NEG)
	{
		motor[motor2] = MAXIMUM_POWER_NEG;
	}
}
// Linearslide encoder program so linearslide goes up to defined height when btn is pressed
	task movelinearslide()
	{
		if (joy2Btn(1) == 1)
	{


		if (encoderValue < smallHeight)
		{
			while (encoderValue < smallHeight)
			{
			encoderValue = nMotorEncoder[LinearSlide];
				motor[LinearSlide] = 127;

			}
			motor[LinearSlide] = 0;

		}
		else
	{
			while (encoderValue > smallHeight)
			{
				encoderValue = nMotorEncoder[LinearSlide];
				motor[LinearSlide] = -127;
			}
			motor[LinearSlide] = 0;

		}




	}


	if (joy2Btn(2) == 1)
	{
		if (encoderValue < mediumHeight)
		{
			while (encoderValue < mediumHeight)
			{
					encoderValue = nMotorEncoder[LinearSlide];
				motor[LinearSlide] = 127;
			}
			motor[LinearSlide] = 0;
		}
		else
	{
			while (encoderValue > mediumHeight)
			{
					encoderValue = nMotorEncoder[LinearSlide];
				motor[LinearSlide] = -127;
			}
			motor[LinearSlide] = 0;
	}

	}

	if (joy2Btn (3) == 1)
	{


		if (encoderValue < highestHeight)
		{
			while (encoderValue < highestHeight)
			{
					encoderValue = nMotorEncoder[LinearSlide];
				motor[LinearSlide] = 127;
			}
			motor[LinearSlide] = 0;
		}
		else
		{
			while (encoderValue > highestHeight)
			{
				encoderValue = nMotorEncoder[LinearSlide];
				motor[LinearSlide] = -127;
			}
			motor[LinearSlide] = 0;
		}


	}

	if (joy2Btn (4) == 1)
	{


		if (encoderValue < centerHeight)
		{
			while (encoderValue < centerHeight)
			{
				encoderValue = nMotorEncoder[LinearSlide];
				motor[LinearSlide] = 127;
			}
			motor[LinearSlide] = 0;
		}
		else
		{
			while (encoderValue > centerHeight)
			{
				encoderValue = nMotorEncoder[LinearSlide];
				motor[LinearSlide] = -127;
			}
			motor[LinearSlide] = 0;
		}
	}
}



task main()
{
	initializeRobot();
//	waitForStart();   // wait for start of tele-op phase
	nMotorEncoder[LinearSlide] = 0;

	while (true)
{
if (joystick.joy2_y2 > -5 && joystick.joy2_y2 < 5)
{
	motor[LinearSlide] = 0;
}
else
{
	motor[LinearSlide] = joystick.joy2_y2;

}

		StartTask (movelinearslide);
//Moves collector

		if (joystick.joy2_y1 > -10 && joystick.joy2_y1 < 10)
		{
			motor[Collector] = 0;
		}
		else
		{
			motor[Collector] = joystick.joy2_y1;
		}

		ForwardSpeedController1 ();

		ForwardSpeedController2 ();

		BackwardSpeedController1 ();

		BackwardSpeedController2 ();

		// Makes turning more efficeint

		if (powermotor1 > powermotor2)
	{
		powermotor2 = powermotor2 -20;
	}
	if (powermotor2 > powermotor1)
	{
		powermotor1 = powermotor1 -20;
	}
	else
	{
		powermotor1 = 0;
		powermotor2 = 0;
	}

	powermotor1 = motor[motor1];
	powermotor2 = motor[motor2];
//Moves servo door
		if (joystick.joy1_TopHat == 0)
					{
						servo[Door] = 110;
					}


					if (joystick.joy1_TopHat == 4)
					{
						servo[Door] = 240;

					}
//Moves hook
		if (joy1Btn(6) == 1)
		{
			motor[Hook] = 30;
		}
		if (joy1Btn(8) == 1)
		{
			motor[Hook] = -30;
			}
		}
	}
