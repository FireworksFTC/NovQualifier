
#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     IR,             sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     TouchSensor,    sensorHiTechnicTouchMux)
#pragma config(Motor,  motorA,          ForkLift,      tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          Hitter,        tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          Hook,          tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     RightDrive,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     LeftDrive,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void goForward(int goPower, const int mTime){// program to make robot go backward/
	motor[RightDrive] =  -goPower;
	motor[LeftDrive] =  -goPower;
	wait1Msec(mTime);
}

void goBack(int goPower, const int mTime) {// program to make robot go forward
	motor[RightDrive] = goPower;
	motor[LeftDrive] =  goPower;
	wait1Msec(mTime);
}

void goLeft(int goPower, const int mTime) {// program to make robot go left
	motor[RightDrive] = -goPower;
	motor[LeftDrive] = goPower;
	wait1Msec(mTime);
}

void goRight(int goPower, const int mTime) {// program to make robot go right
	motor[RightDrive] = goPower;
	motor[LeftDrive] =  -goPower;
	wait1Msec(mTime);
}

void goUp (int goPower, const int mTime) {
	motor[Hook] = -goPower;
	wait1Msec(mTime);
}

void goDown (int goPower, const int mTime) {
	motor[Hook] = goPower;
	wait1Msec(mTime);
}

void goGrab (int goPower, const int mTime) {
	motor[Hitter] = -goPower;
	wait1Msec(mTime);
}

void goRelease (int goPower, const int mTime) {
	motor[Hitter] = goPower;
	wait1Msec(mTime);
}


void initializeRobot()
{
	return;
}



task main()
	{
	goBack(10, 1000);// going forward toward IR sensor
	wait1Msec(2000);// waiting
		if(SensorValue[IR] >= 5){// condition of checking value of IR sensor; if it is greater than or equal to 5 on this check, it is in the vertical position in relation to the robot
			goForward(10, 750);// going away from center goal with IR sensor in order to kick kick-stand next
			goRight(30, 2500); // turning right to get nearer to center goal with IR sensor
			goBack(10, 9000); // going forward in the above direction
			goLeft(30, 3000);// turning toward the kick stand
			goBack(10, 750);
			goGrab(30, 500);// hit kick stand
			goRelease(50, 800);// hit kick stand
		}
		else{// if the IR value wasn't greater than or equal to five during the first check, it will perform the following functions
			goLeft(30, 1000);// under the above else, the center goal must be in either the crooked, or horizontal positions(in relation to the robot's starting position), so the robot will turn left in order to get closer to the IR sensor
			goBack(20, 1500);// mover forward in the above direction
			if(SensorValue[IR] >= 5){// check the IR value, and if it is greater tahn or euqal to 5 at this point, it is in the crooked position(in relation to the robot's starting position)
				goForward(20, 1500);// Backing out in order to get in position to hit the kick stand
				goRight(30, 2500);// turning to be parallel to center gaol
				goBack(20, 1500);// moving forward in above specified direction
				goLeft(30, 1000);// turn into poisiton to hit kick stand
				goGrab(30, 500);// hit kick stand
			goRelease(80, 1000);// hit kick stand
			goRight(50, 3500);// move Right in order to ensure that kick stand gets knocked down
			}
			else{// if the IR value wasn't greater tahn or equalt of ive during the second check, it will perform the following functions; there is only one poisiton possible left, the horizontal one(in relation to the robot's starting poisiton), so the following code is for it
			goRight(30, 1000);// since we originally had turned the robot left before the second IR check, we now turn right to go back to the straight forward poistion
			goBack(20, 280);// go forward toward the kick stand
			goGrab(30, 500);// hit kick stand
			goRelease(50, 800);// hit kick stand
			goForward(40, 1500);// move Backward in order to ensure that kick stand gets knocked down
			}
		}
}
